
package fr.inria.astor.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

import fr.inria.astor.approaches.extensions.minimpact.validator.ProcessEvoSuiteValidator;
import fr.inria.astor.core.entities.ProgramVariant;
import fr.inria.astor.core.entities.validation.TestCaseVariantValidationResult;
import fr.inria.astor.core.manipulation.MutationSupporter;
import fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler;
import fr.inria.astor.core.manipulation.bytecode.entities.CompilationResult;
import fr.inria.astor.core.setup.ConfigurationProperties;
import fr.inria.astor.core.setup.ProjectRepairFacade;
import fr.inria.astor.core.solutionsearch.extension.VariantCompiler;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtType;

/**
 * 
 * @author Matias Martinez
 *
 */
public class EvoSuiteFacade {

	public static String EVOSUITE_SUFFIX = "_ESTest";
	public static String EVOSUITE_scaffolding_SUFFIX = "_ESTest_scaffolding";

	static Logger logger = Logger.getLogger(Thread.currentThread().getName());

	/**
	 * Executing evosuite. For each Affected class from the program variant, we
	 * create the related TestUnit using evosuite
	 * 
	 * @param variant
	 * @param projectFacade
	 * @param outES
	 *            where the code generated by ES is deposed
	 * @return
	 * @throws Exception
	 */
	public boolean runEvosuite(ProgramVariant variant, ProjectRepairFacade projectFacade, String outES)
			throws Exception {
		// If the variant does not have operators, we use all classes.
		List<CtType<?>> types = (!variant.computeAffectedClassesByOperators().isEmpty())
				? variant.computeAffectedClassesByOperators() : variant.getAffectedClasses();

		List<String> affectedTypes = types.stream().map(e -> e.getQualifiedName()).collect(Collectors.toList());

		return runEvosuite(variant, affectedTypes, projectFacade, outES, true);
	}

	/**
	 * Executing evosuite. For each Affected class from the program variant, we
	 * create the related TestUnit using evosuite Argument overOriginal indicate
	 * if we generate over the fixed version or original version (buggy)
	 * 
	 * @param variant
	 * @param projectFacade
	 * @return
	 * @throws Exception
	 */
	public boolean runEvosuite(ProgramVariant variant, List<String> testToCreate, ProjectRepairFacade projectFacade,
			String outES, boolean processOriginal) throws Exception {
		int nrGenerated = 0;
		List<URL> originalURL = new ArrayList<>(
				Arrays.asList(projectFacade.getClassPathURLforProgramVariant(ProgramVariant.DEFAULT_ORIGINAL_VARIANT)));
		// If we process a variant
		if (!processOriginal) {
			String bytecodeOutput = projectFacade.getOutDirWithPrefix(variant.currentMutatorIdentifier());
			File fByteOutput = new File(bytecodeOutput);
			if (!fByteOutput.exists()) {
				throw new IllegalStateException("Bytecode not generated for " + variant.currentMutatorIdentifier());
			}
			originalURL.add(0, fByteOutput.toURL());
		}

		logger.debug("---> creating evosuite tests for: " + testToCreate);

		File fESout = new File(outES);
		fESout.mkdirs();

		URL[] SUTClasspath = originalURL.toArray(new URL[0]);

		logger.debug("Creating test cases using evosuite for: " + testToCreate.size() + " classes, mode: "
				+ ((ConfigurationProperties.getPropertyBool("evoDSE")) ? "DSE" : "LS"));

		long init = System.currentTimeMillis();

		boolean reponse = true;
		int counter = 0;
		for (String ctType : testToCreate) {
			// generate a process for running evosuite
			String[] command = new String[] { "-class", ctType, //
					"-projectCP", urlArrayToString(SUTClasspath), //
					"-base_dir", outES //
			};
			String[] defaultsParameters = null;
			String defaultESParameters = ConfigurationProperties.getProperty("ESParameters");
			if (defaultESParameters != null && !"".equals(defaultESParameters.trim())) {
				if (!(defaultESParameters.contains("-seed") || defaultESParameters.contains("-Drandom_seed"))) {
					defaultESParameters += (defaultESParameters
							.charAt(defaultESParameters.length() - 1) != File.pathSeparatorChar) ? (File.pathSeparator)
									: "";
					defaultESParameters += "-Drandom_seed" + (File.pathSeparator)
							+ ConfigurationProperties.getProperty("seed");
				}
				defaultsParameters = defaultESParameters.split(File.pathSeparator);
			} else {
				defaultsParameters = new String[] {
						// Default options:
						"-Dglobal_timeout",
						Integer.toString(2 * Integer.valueOf(ConfigurationProperties.getProperty("evosuitetimeout")))// Before
																														// commented
						, "-seed", ConfigurationProperties.getProperty("seed")//
						, "-Drandom_seed", ConfigurationProperties.getProperty("seed"), //
						"-Dsearch_budget", ConfigurationProperties.getProperty("evosuitetimeout"), //
						//// Stopping conditions options: [MAXSTATEMENTS,
						//// MAXTESTS, MAXTIME, MAXGENERATIONS,
						//// MAXFITNESSEVALUATIONS, TIMEDELTA])
						"-Dstopping_condition", "MaxTime", "-Dsandbox", "false", //
						"-Dno_runtime_dependency", "true", //
						"-mem", "2000" };//
			}
			command = StringUtil.concat(command, defaultsParameters);

			if (ConfigurationProperties.getPropertyBool("evoDSE")) {

				String[] dse = new String[] { "-Dlocal_search_rate", "2", // "8",
																			// //
						"-Dlocal_search_budget", "5", //
						"-Dlocal_search_budget_type", "TIME", //
						"-Dlocal_search_adaptation_rate", "0.33", //
						"-Dlocal_search_probability", "1.0", //
						"-Ddse_probability", "1.0",//
				};
				command = StringUtil.concat(command, dse);
			}

			logger.debug("Creating test for " + ctType + " " + (++counter) + "/" + testToCreate.size());
			boolean sucess = runProcess(null, command);
			logger.debug("---> Evo OK? " + sucess + " ");
			reponse &= sucess;
			nrGenerated += (sucess) ? 1 : 0;

		}
		long time = (System.currentTimeMillis() - init) / 1000;
		logger.debug(
				"Evo end in total " + time + " seconds for generating " + nrGenerated + " over " + testToCreate.size());
		return reponse;
	}

	public List<CtType<?>> getClassesToProcess(ProgramVariant variant) {
		List<CtType<?>> typesToProcess = null;

		if (ConfigurationProperties.getPropertyBool("evo_buggy_class")) {

			//
			if (ConfigurationProperties.getPropertyBool("evo_affected_by_op")) {
				logger.info("Affected Buggy classes");
				typesToProcess = variant.computeAffectedClassesByOperators();
			} else {
				logger.info("All Buggy classes");
				typesToProcess = variant.getAffectedClasses();
			}

		} else

		{
			typesToProcess = new ArrayList<>();
			for (CtClass<?> classes : variant.getModifiedClasses()) {
				typesToProcess.add(classes);
			}
		}
		logger.info("Classes for generating test: "
				+ typesToProcess.stream().map(e -> e.getQualifiedName()).collect(Collectors.toList()));
		return typesToProcess;
	}

	// TODO: cloned
	protected static String urlArrayToString(URL[] urls) {
		String s = "";
		if (urls == null)
			return s;
		for (int i = 0; i < urls.length; i++) {
			URL url = urls[i];
			s += url.getPath() + File.pathSeparator;
		}
		return s;
	}

	// TODO: cloned
	protected static URL[] redefineURL(File foutgen, URL[] originalURL) throws MalformedURLException {
		List<URL> urls = new ArrayList<URL>();
		urls.add(foutgen.toURL());
		for (int i = 0; (originalURL != null) && i < originalURL.length; i++) {
			urls.add(originalURL[i]);
		}

		return (URL[]) urls.toArray(originalURL);
	}

	/**
	 * 
	 * @param urlClasspath
	 * @param argumentsEvo
	 * @return
	 */
	protected boolean runProcess(URL[] urlClasspath, String[] argumentsEvo) {
		Process p = null;

		String javaPath = ConfigurationProperties.getProperty("jvm4evosuitetestexecution");
		javaPath += File.separator + "java";

		try {

			List<String> command = new ArrayList<String>();
			command.add(javaPath);
			command.add("-jar");
			command.add(new File(ConfigurationProperties.getProperty("evosuitejar")).getAbsolutePath());

			for (String arg : argumentsEvo) {
				command.add(arg);
			}
			logger.debug("EvoGenerate " + (command));
			ProcessBuilder pb = new ProcessBuilder(command.toArray(new String[command.size()]));
			pb.redirectOutput();
			pb.redirectErrorStream(true);
			pb.directory(new File((ConfigurationProperties.getProperty("location"))));
			p = pb.start();

			p.waitFor((ConfigurationProperties.getPropertyInt("evosuitetimeout") * 2 * 1000), TimeUnit.MILLISECONDS);

			String out = readOut(p);
			logger.debug("ES generation output: \n " + out);
			p.destroyForcibly();
			return true;
		} catch (IOException | InterruptedException | IllegalThreadStateException ex) {
			logger.error(ex.getMessage(), ex);
			if (p != null)
				p.destroyForcibly();
		}
		return false;
	}

	public List<CtClass> reificateEvoSuiteTest(String evoTestpath, String[] classpath) {
		logger.debug("Compiling ES code " + evoTestpath + " with CL " + Arrays.toString(classpath));
		logger.debug("Es dir content: " + Arrays.toString(new File(evoTestpath).listFiles()));
		MutationSupporter mutatorSupporter = MutationSupporter.currentSupporter;
		String codeLocation = evoTestpath;

		try {
			MutationSupporter.getFactory().getModel().setBuildModelIsFinished(false); // avoid getting errors when trying to build back the model
			mutatorSupporter.buildModel(codeLocation, classpath);
		} catch (Exception e) {
			e.printStackTrace();
			logger.error(e.getMessage());
			MutationSupporter.getFactory().getModel().setBuildModelIsFinished(false); // avoid getting errors when trying to build back the model
			MutationSupporter.getFactory().getEnvironment()
					.setComplianceLevel(ConfigurationProperties.getPropertyInt("alternativecompliancelevel"));
			mutatorSupporter.buildModel(codeLocation, classpath);

		}

		List<CtType<?>> allTypes = MutationSupporter.getFactory().Type().getAll();
		List<CtClass> ESTestClasses = new ArrayList<>();
		for (CtType<?> ctType : allTypes) {
			if (ctType.getSimpleName().endsWith(EVOSUITE_SUFFIX)
					|| ctType.getSimpleName().endsWith(EVOSUITE_scaffolding_SUFFIX)) {
				ESTestClasses.add((CtClass) ctType);
			}
		}
		logger.debug("CtClass from evosuite: #" + ESTestClasses.size());
		return ESTestClasses;
	}

	/**
	 * Given a program variant, we create using a program variant a) the
	 * Evosuite test b) the spoon model of the Evosuite test classes.
	 * 
	 * @param projectFacade
	 * @param variant
	 * @return
	 * @throws Exception
	 */
	public List<CtClass> createEvoTestModel(ProjectRepairFacade projectFacade, ProgramVariant variant)
			throws Exception {

		logger.info("Executing evosuite");
		// Generating Evosuite test class from the variant
		// Matias: TODO: I would like that this method return a
		// map<CtClass:TestCasesGenerated(File)>
		String outES = projectFacade.getInDirWithPrefix(ConfigurationProperties.getProperty("evosuiteresultfolder"));
		boolean executed = this.runEvosuite(variant, projectFacade, outES);
		logger.debug("Evo result: " + executed);

		// CHECKING EVO OUTPUT
		String testEScodepath = projectFacade
				.getInDirWithPrefix(ConfigurationProperties.getProperty("evosuiteresultfolder"));
		File esPath = new File(testEScodepath);

		logger.info("Evo output: " + esPath);

		logger.info("Loading EvoTest model");
		// CREATING CLASSPATH FOR EXECUTING EVO TESTS
		String bytecodeSUTLocation = projectFacade.getOutDirWithPrefix(ProgramVariant.DEFAULT_ORIGINAL_VARIANT);

		String classpathForModelizeEvoSuite = "";

		classpathForModelizeEvoSuite += (new File(ConfigurationProperties.getProperty("evosuitejar"))
				.getAbsolutePath());

		classpathForModelizeEvoSuite += (File.pathSeparator + projectFacade.getProperties().getDependenciesString());
		classpathForModelizeEvoSuite += (File.pathSeparator + bytecodeSUTLocation);

		String[] classpathForModelizeEvoSuiteTest = classpathForModelizeEvoSuite.split(File.pathSeparator);

		// We create the Spoon model for the evosuite test generated
		List<CtClass> classes = reificateEvoSuiteTest(testEScodepath, classpathForModelizeEvoSuiteTest);

		return classes;

	}

	public TestCaseVariantValidationResult saveAndExecuteEvoSuite(ProjectRepairFacade projectFacade,
			ProgramVariant variant, List<CtClass> ctclasses) throws Exception {

		String classpathForCompileSpoon = "";
		classpathForCompileSpoon = projectFacade.getProperties().getDependenciesString() + File.pathSeparator
				+ projectFacade.getOutDirWithPrefix(variant.currentMutatorIdentifier()) + File.pathSeparator//
				+ new File(ConfigurationProperties.getProperty("evosuitejar")).getAbsolutePath() + File.pathSeparator
				+ projectFacade.getOutDirWithPrefix(variant.DEFAULT_ORIGINAL_VARIANT) + File.pathSeparator
				+ System.getProperty("java.class.path");
		;

		logger.info("Classpath " + classpathForCompileSpoon);
		String[] classpathForCreateModel = classpathForCompileSpoon.split(File.pathSeparator);

		// Compile evo classes from spoon model
		VariantCompiler compiler = new SpoonClassCompiler(MutationSupporter.getFactory());
		CompilationResult compilation = compiler.compile(ctclasses, Converters.toURLArray(classpathForCreateModel));

		if (!compilation.compiles() || compilation.getByteCodes().values().isEmpty()) {
			logger.error("Error at compiling evotest classes");
			return null;
		}
		logger.debug("EvoSuite compiled ok " + compilation.compiles());

		//// Save compiled
		String outPutTest = projectFacade
				.getOutDirWithPrefix("/evosuite/evosuite-tests_" + variant.currentMutatorIdentifier());
		File fbyteEvo = new File(outPutTest);
		logger.info("Saving evotest bytecode at " + fbyteEvo);
		MutationSupporter.currentSupporter.getOutput().saveByteCode(compilation, fbyteEvo);

		List<String> testToExecute = new ArrayList<>();
		for (CtClass evoTest : ctclasses) {
			if (!evoTest.getQualifiedName().endsWith(EVOSUITE_scaffolding_SUFFIX))
				testToExecute.add(evoTest.getQualifiedName());
		}

		String classpathForRunTest = classpathForCompileSpoon + (File.pathSeparator) + outPutTest + File.pathSeparator
				+ System.getProperty("java.class.path");
		;
		logger.info("Process classpath " + classpathForRunTest);

		ProcessEvoSuiteValidator evoProcess = new ProcessEvoSuiteValidator();
		TestCaseVariantValidationResult evoResult = evoProcess.executeRegressionTesting(
				Converters.toURLArray(classpathForRunTest.split(File.pathSeparator)), testToExecute);

		return evoResult;
	}

	private String readOut(Process p) {
		String out = "";
		String all = "";
		try {
			BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));
			String line;
			while ((line = in.readLine()) != null) {
				if (line.startsWith("Writing JUnit test case")) {
					out += line + "\n";
				}
				all += line + "\n";

			}
			if ("".equals(out)) {
				return all;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return out;
	}

	private List<CtType> obtainBuggyButLatterModif(ProgramVariant variant) {
		List<CtType> types = new ArrayList<>();
		for (CtType affected : variant.getAffectedClasses()) {

			boolean add = false;
			for (CtType modif : variant.getModifiedClasses()) {
				if (modif.getQualifiedName().equals(affected.getQualifiedName())) {
					add = true;
					break;
				}
				if (add) {
					types.add(affected);
				}
			}
		}
		return types;
	}

	private static void printLines(String name, InputStream ins) throws Exception {
		String line = null;
		BufferedReader in = new BufferedReader(new InputStreamReader(ins));
		while ((line = in.readLine()) != null) {
			logger.debug(name + " " + line);
		}
	}

	public static void runProcess(String[] command) throws Exception {
		logger.debug("Executing compilation : " + Arrays.toString(command));
		Process pro = Runtime.getRuntime().exec(command);
		printLines(command + " stderr:", pro.getErrorStream());
		pro.waitFor();
		logger.debug(command + " exitValue() " + pro.exitValue());
	}

}
